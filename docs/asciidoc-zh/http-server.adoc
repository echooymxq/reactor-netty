:sourcedir: ./../../reactor-netty-http/src/main/java
:examplesdir: ./../../reactor-netty-examples/src/main/java/reactor/netty/examples/documentation/http/server
:javadoc: https://projectreactor.io/docs/netty/release/api

[[http-server]]
= HTTP Server

`Reactor Netty` 提供易使用和配置的
{javadoc}/reactor/netty/http/server/HttpServer.html[`HttpServer`]。
它隐藏了创建 `HTTP` 服务所需的大部分 `Netty` 功能，
并且增加了 `Reactive Streams` 背压。

== 启动和停止

为了一个HTTP服务，你必须创建和配置一个
{javadoc}/reactor/netty/http/server/HttpServer.html[HttpServer] 实例。
默认情况下，`host` 配置为任何本地地址，并在调用 `bind` 操作时，系统会选择一个临时端口。
以下示例显示了如何创建和配置一个 `HttpServer` 实例：

====
[source,java,indent=0]
.{examplesdir}/create/Application.java
----
include::{examplesdir}/create/Application.java[lines=18..31]
----
<1> 创建一个配置就绪的 {javadoc}/reactor/netty/http/server/HttpServer.html[HttpServer] 实例。
<2> 以阻塞方式启动服务，并等待其完成初始化。
====

返回的 {javadoc}/reactor/netty/DisposableServer.html[`DisposableServer`]
提供一个简单的服务API，包括 {javadoc}/reactor/netty/DisposableChannel.html#disposeNow-java.time.Duration-[`disposeNow()`]，这将以阻塞的方式关闭服务器。

=== Host和Port

要在特定的 `host` 和 `port` 服务，你可以在 `HTTP` 服务中应用以下配置：

====
[source,java,indent=0]
.{examplesdir}/address/Application.java
----
include::{examplesdir}/address/Application.java[lines=18..33]
----
<1> 配置 `HTTP` 服务 host
<2> 配置 `HTTP` 服务 port
====

== HTTP路由

为 `HTTP` 服务定义路由要求配置提供 {javadoc}/reactor/netty/http/server/HttpServerRoutes.html[`HttpServerRoutes`] builder。
以下示例显示了如何做到这一点：

====
[source,java,indent=0]
.{examplesdir}/routing/Application.java
----
include::{examplesdir}/routing/Application.java[lines=18..41]
----
<1> 为 `/hello` 的 `GET` 请求服务，并返回 `Hello World!`
<2> 为 `/echo` 的 `POST` 请求服务，并将请求体作为返回响应发送。
<3> 为 `/path/{param}` 的 `GET` 请求服务，并返回路径参数的值。
<4> 为 `/ws` websocket服务，并将接收到的数据作为返回数据返回。
====

NOTE: 服务路由是唯一的，并且仅调用声明顺序中的第一个匹配项。

=== SSE

以下示例显示了如何配置 `HTTP` 服务以提供 `Server-Sent Events`：

====
[source,java,indent=0]
.{examplesdir}/sse/Application.java
----
include::{examplesdir}/sse/Application.java[lines=18..76]
----
====

=== 静态资源

以下示例显示了如何配置 `HTTP` 服务以提供静态资源：

====
[source,java,indent=0]
.{examplesdir}/staticresources/Application.java
----
include::{examplesdir}/staticresources/Application.java[lines=18..37]
----
====

== 写数据

为了发送数据到连接的客户端，你必须使用以下方法
{javadoc}/reactor/netty/http/server/HttpServer.html#handle-java.util.function.BiFunction-[`handle(...)`] 或
{javadoc}/reactor/netty/http/server/HttpServer.html#route-java.util.function.Consumer-[`route(...)`] 之一连接一个I/O处理器。
这个I/O处理器可以访问 {javadoc}/reactor/netty/http/server/HttpServerResponse.html[`HttpServerResponse`] 来写入数据。以下示例使用 `handle(...)` 方法：

====
[source,java,indent=0]
.{examplesdir}/send/Application.java
----
include::{examplesdir}/send/Application.java[lines=18..33]
----
<1> 发送 `hello` 字符到连接的客户端
====

=== 添加Header和其他元数据

当发送数据到连接的客户端时，可能需要发送其他的headers，cookies， status code，和其他元数据。
你可以通过使用
{javadoc}/reactor/netty/http/server/HttpServerResponse.html[`HttpServerResponse`] 来提供其他的元数据。
以下示例显示了如何做到这一点：

====
[source,java,indent=0]
.{examplesdir}/send/headers/Application.java
----
include::{examplesdir}/send/headers/Application.java[lines=18..40]
----
====

=== 压缩

通过 `Accept-Encoding` 请求头，可以配置 `HTTP` 服务发送一个压缩的响应。

`Reactor Netty` 提供了三种不同压缩发送数据的策略：

* `compress(boolean)`: 根据提供布尔值，压缩启用(`true`) 或禁用 (`false`)。
* `compress(int)`: 一旦响应超过给定的值（以字节为单位），就会进行压缩。
* `compress(BiPredicate<HttpServerRequest, HttpServerResponse>)`: 如果断言返回 `true`，就会进行压缩。

以下示例使用 `compress` 方法（设置为 `true`）来启用压缩：

====
[source,java,indent=0]
.{examplesdir}/compression/Application.java
----
include::{examplesdir}/compression/Application.java[lines=18..38]
----
====

== 消费数据

为了从连接的客户端的接收数据，你必须使用以下方法
{javadoc}/reactor/netty/http/server/HttpServer.html#handle-java.util.function.BiFunction-[`handle(...)`] 或
{javadoc}/reactor/netty/http/server/HttpServer.html#route-java.util.function.Consumer-[`route(...)`] 之一连接一个I/O处理器。
这个I/O处理器可以访问 {javadoc}/reactor/netty/http/server/HttpServerRequest.html[`HttpServerRequest`] 来读取数据。

以下示例使用 `handle(...)` 方法：

====
[source,java,indent=0]
.{examplesdir}/read/Application.java
----
include::{examplesdir}/read/Application.java[lines=18..32]
----
<1> 从连接的客户端接收数据
====

=== 读取Header，URL参数，和其他元数据

当从连接的客户端接收数据时，可能需要检查请求header，parameter，和其他元数据。你可以通过使用
{javadoc}/reactor/netty/http/server/HttpServerRequest.html[`HttpServerRequest`] 获取其他的元数据。
以下示例显示了如何做到这一点：

====
[source,java,indent=0]
.{examplesdir}/read/headers/Application.java
----
include::{examplesdir}/read/headers/Application.java[lines=18..40]
----
====

==== 获取远程（Client）地址

除了从请求中获取元数据，还可以接收 `host (服务)` 地址，`远程 (client)` 地址和 `scheme`。根据选择的工厂方法，可以直接从channel或通过 `Forwarded` 或 `X-Forwarded-*` `HTTP` 请求头提取信息。
以下示例显示了如何做到这一点：

====
[source,java,indent=0]
.{examplesdir}/clientaddress/Application.java
----
include::{examplesdir}/clientaddress/Application.java[lines=18..38]
----
<1> 可以的话，指定从 `Forwarded` 和 `X-Forwarded-*` `HTTP` 请求头中获取信息。
<2> 返回远程（client)节点的地址。
====

还可以自定义 `Forwarded` 或 `X-Forwarded-*` header处理器的行为。
以下示例显示了如何做到这一点：

====
[source,java,indent=0]
.{examplesdir}/clientaddress/CustomForwardedHeaderHandlerApplication.java
----
include::{examplesdir}/clientaddress/CustomForwardedHeaderHandlerApplication.java[lines=18..52]
----
<1> 添加一个自定义header处理器。
<2> 返回远程（client)节点的地址。
====

=== HTTP请求解码器

默认情况下，`Netty` 为请求配置作了一些限制，例如：

* 初始行的最大长度。
* 所有header的最大长度。
* content或每个chunk的最大长度。

更多的信息，看 https://netty.io/4.1/api/io/netty/handler/codec/http/HttpRequestDecoder.html[`HttpRequestDecoder`]
和 https://netty.io/4.1/api/io/netty/handler/codec/http/HttpServerUpgradeHandler.html[`HttpServerUpgradeHandler`]

默认情况下，`HTTP` 服务使用以下配置：

====
[source,java,indent=0]
.{sourcedir}/reactor/netty/http/HttpDecoderSpec.java
----
include::{sourcedir}/reactor/netty/http/HttpDecoderSpec.java[lines=29..33]
----
====
====
[source,java,indent=0]
.{sourcedir}/reactor/netty/http/server/HttpRequestDecoderSpec.java
----
include::{sourcedir}/reactor/netty/http/server/HttpRequestDecoderSpec.java[lines=34..39]
----
====

当需要更改默认设置时，可以配置 `HTTP` 服务如下：

====
[source,java,indent=0]
.{examplesdir}/requestdecoder/Application.java
----
include::{examplesdir}/requestdecoder/Application.java[lines=18..34]
----
<1> 所有header的最大长度会是 `16384`。
当超过这个值时，一个
https://netty.io/4.1/api/io/netty/handler/codec/TooLongFrameException.html[TooLongFrameException]
会被抛出。
====

== TCP级的配置

当需要改变TCP级当配置时，可以使用以下片段来扩展默认的 `TCP` 服务配置：

====
[source,java,indent=0]
.{examplesdir}/channeloptions/Application.java
----
include::{examplesdir}/channeloptions/Application.java[lines=18..33]
----
====

更多关于TCP级的配置详情看 <<tcp-server>>。

=== Wire Logger

`Reactor Netty` 提供了wire logging用于检测节点之间的流量。
默认情况下，wire logging未启用。
为了启用它，你必须设置 `reactor.netty.http.server.HttpServer` 日志级别为 `DEBUG` 且使用以下配置：

====
[source,java,indent=0]
.{examplesdir}/wiretap/Application.java
----
include::{examplesdir}/wiretap/Application.java[lines=18..32]
----
<1> 启用wire logging
====

== SSL和TLS

当你需要SSL或TLS，你可以使用下面例子所示的配置：
默认情况下，如果 `OpenSSL` 是可用的，
https://netty.io/4.1/api/io/netty/handler/ssl/SslProvider.html#OPENSSL[`SslProvider.OPENSSL`]
将作为一个provider。否则会使用
https://netty.io/4.1/api/io/netty/handler/ssl/SslProvider.html#JDK[`SslProvider.JDK`]。
通过 https://netty.io/4.1/api/io/netty/handler/ssl/SslContextBuilder.html#sslProvider-io.netty.handler.ssl.SslProvider-[`SslContextBuilder`]
或设置 `-Dio.netty.handler.ssl.noOpenSsl=true` 来切换provider。

以下示例使用 `SslContextBuilder`：

====
[source,java,indent=0]
.{examplesdir}/security/Application.java
----
include::{examplesdir}/security/Application.java[lines=18..39]
----
====

=== 服务名称指示
可以配置 `HTTP` 服务与多个 `SslContext` 映射到一个特定的域名。
配置 `SNI` 映射时，可以使用一个确切的或包含通配符的域名。

以下示例使用了一个包含通配符的域名：

====
[source,java,indent=0]
.{examplesdir}/sni/Application.java
----
include::{examplesdir}/sni/Application.java[lines=18..47]
----
====

== HTTP访问日志

目前的日志支持只提供 https://en.wikipedia.org/wiki/Common_Log_Format[Common Log Format]。

可以使用 `-Dreactor.netty.http.server.accessLogEnabled=true` 来启用 `HTTP` 访问日志。
默认情况下是禁用的。

可以使用以下配置 (对于Logback或其他类似日志框架) 来生成单独的 `HTTP` 访问日志文件：

====
[source,xml]
----
<appender name="accessLog" class="ch.qos.logback.core.FileAppender">
    <file>access_log.log</file>
    <encoder>
        <pattern>%msg%n</pattern>
    </encoder>
</appender>
<appender name="async" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="accessLog" />
</appender>

<logger name="reactor.netty.http.server.AccessLog" level="INFO" additivity="false">
    <appender-ref ref="async"/>
</logger>
----
====

== HTTP/2

默认情况下，`HTTP` 服务支持 `HTTP/1.1`。如果需要，则可以配置为 `HTTP/2`。
除了协议配置，如果需要 `H2` 而不是 `H2C (明文)`，则必须配置SSL。

NOTE: 由于JDK8（尽管一些厂商将ALPN移植到了JDK8）不支持 "`开箱即用`" 的应用层协议协商(ALPN)，你额外需要一个支持它的本地
-- 例如， https://netty.io/wiki/forked-tomcat-native.html[`netty-tcnative-boringssl-static`] 。

下面列出一个简单的 `H2` 例子：

====
[source,java,indent=0]
.{examplesdir}/http2/H2Application.java
----
include::{examplesdir}/http2/H2Application.java[lines=18..44]
----
<1> 配置服务只支持 `HTTP/2`
<2> 配置 `SSL`
====

现在，该应用表现如下：

====
[source,bash]
----
$ curl --http2 https://localhost:8080 -i
HTTP/2 200

hello
----
====

下面列出一个简单的 `H2C` 例子：

====
[source,java,indent=0]
.{examplesdir}/http2/H2CApplication.java
----
include::{examplesdir}/http2/H2CApplication.java[lines=18..41]
----
====

现在，该应用表现如下：

====
[source,bash]
----
$ curl --http2-prior-knowledge http://localhost:8080 -i
HTTP/2 200

hello
----
====

=== 协议选择

====
[source,java,indent=0]
.{sourcedir}/reactor/netty/http/HttpProtocol.java
----
include::{sourcedir}/reactor/netty/http/HttpProtocol.java[lines=24..52]
----
====

== 指标
HTTP服务内置集成了 https://micrometer.io/[`Micrometer`]。
它会暴露所有以 `reactor.netty.http.server` 开头的指标。

下表提供了HTTP服务指标的信息：

[width="100%",options="header"]
|=======
| 指标名称 | 类型 | 描述
| reactor.netty.http.server.data.received | DistributionSummary | 收到的数据量，以字节为单位
| reactor.netty.http.server.data.sent | DistributionSummary | 发送的数据量，以字节为单位
| reactor.netty.http.server.errors | Counter | 错误发生的数量
| reactor.netty.http.server.data.received.time | Timer | 接收数据花费的时间
| reactor.netty.http.server.data.sent.time | Timer | 发送数据花费的时间
| reactor.netty.http.server.response.time | Timer | 请求/响应的总时间
|=======

额外的其他指标：

include::alloc-metrics.adoc[]

以下示例启用了该集成：

====
[source,java,indent=0]
.{examplesdir}/metrics/Application.java
----
include::{examplesdir}/metrics/Application.java[lines=18..52]
----
<1> 对带有 `URL` 标签的计量器设置上限
<2> 如果可能，模版URL将作为URL标签值
<3> 启用内置集成的Micrometer
====

NOTE: 为了避免启用metric导致内存和CPU负荷增加，尽可能将真实的URL转换为模版URL。
如果不转换为模版的形式，每个不同的URL都会创建一个不同的标签，metric将会占用大量的内存。

NOTE: 总是为URL标签计量器设置上限，在无法将真实的URL进行模版化的时候，配置计量器的上限通常会有所作用。
查看更多信息 https://micrometer.io/docs/concepts#_denyaccept_meters[`maximumAllowableTags`]。

当HTTP服务指标需要与 `Micrometer` 以外的系统集成或自己与 `Micrometer` 集成时，你可以提供自己的指标记录器，如下所示：

====
[source,java,indent=0]
.{examplesdir}/metrics/custom/Application.java
----
include::{examplesdir}/metrics/custom/Application.java[lines=18..41]
----
<1> 启用HTTP服务指标并且提供 {javadoc}/reactor/netty/http/server/HttpServerMetricsRecorder.html[`HttpServerMetricsRecorder`] 实现。
====

== 进程间通信（Unix Domain Sockets）
`HTTP` 服务在使用本地传输时支持Unix Domain Sockets (UDS)。

以下示例显示了如何使用UDS支持：

====
[source,java,indent=0]
.{examplesdir}/uds/Application.java
----
include::{examplesdir}/uds/Application.java[lines=18..33]
----
<1> 指定要使用的 `DomainSocketAddress`
====
